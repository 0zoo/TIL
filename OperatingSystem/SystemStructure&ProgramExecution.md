
https://core.ewha.ac.kr/publicview/C0101020140311132925816476?vmode=f


![](https://user-images.githubusercontent.com/38287485/52633663-7b83f480-2f08-11e9-87c3-de2a41d6a47a.png)

![](https://user-images.githubusercontent.com/38287485/52633668-7e7ee500-2f08-11e9-8c08-d8bf1fe9e600.png)

CPU: 메모리의 인스트럭션을 계속 읽으면서 실행


- cpu
	- interrupt line: 
	- mode bit: cpu를 운영체제가 갖고 있는지 사용자 프로그램이 갖고 있는지
	- registers: 메모리보다 더 빠르면서 저장할 수 있는 공간



IO 작업은 CPU가 일을 직접 하는 것이 아니라 컨트롤러에게 일을 시킨다. 


무한루프를 도는 경우?? -> timer 하드웨어를 갖고 있는 이유. 독점을 방지하기 위해

하나의 인스트럭션 실행이 끝나면 인터럽트 라인 체크하고 
인터럽트 새로 들어온 것이 없다면 없으면 다시 실행하고 .. 반복하는 작업 루틴. 

타이머 인터럽트가 되면  CPU 하던 일을 멈추고 제어권이 운영체제로 넘어간다.  


Mode bit의 역할?? 0일때는 모든 접근이 가능하도록. 1일 때는 제한된 접근(보안상) 

### Timer

- 정해진 시간이 흐른 뒤 운영체제에게 제어권이 넘어가도록 인터럽트를 발생시킴
- 타이머는 매 clock tick마다 1씩 감소
- 타이머 0이 되면 타이머 인터럽트 발생
- CPU 독점 방지

타이머는 time sharing을 구현하기 위해 널리 이용됨.

타이머는 현재 시간을 계산하기 위해서도 사용


### Device Controller

- I/O device controller: 
	- 장치 유형을 관리하는 일종의 작은 CPU
	- 제어 정보를 위해 control register, status register를 가짐
	- local buffer를 가짐 (일종의 data register)
- I/O는 실제 device와 local buffer 사이에서 일어남
- device controller는 I/O가 끝났을 경우 interrupt로 CPU에 그 사실을 알림


장치 구동기(device driver)
: OS 코드 중 각 장치별 처리 루틴 -> 소프트웨어

장치제어기(device controller)
: 각 장치를 통제하는 일종의 작은 CPU -> 하드웨어


CPU는 메모리, 로컬 버퍼 둘 다 접근 가능.
작은 cpu들은 자기 자신의 로컬 버퍼만 접근할 수 있음. 
이렇게 되면 CPU가 너무 인터럽트 많이 당한다.. 효율적이지 못함.

=> DMA 컨트롤러 : 직접 메모리에 접근할 수 있는.. 
CPU는 계속 자기 역할을 하고 있고, dma가 직접 메모리에 복사하는 일까지 해줌. cpu에 인터럽트 1번만 걸어서 보고. 이렇게 되면 cpu가 중간에 인터럽트 당하는 빈도가 적어저 효율적으로 운용 가능.

동시에 메모리 접근하는 경우를 조율하는 역할 - memory conroller 




### 입출력의 수행

- 모든 입출력 명령은 특권 명령
- 사용자 프로그램은 어떻게 I/O를 하는가?
	- 시스템 콜 
		- 운영체제에게 요청
		- 일반적인 함수 호출과는 다르다. (그냥 메모리 주소를 바꾸는 것 x)
		mode bit이 1이기 때문에 접근 불가..
	- trap을 사용하여 인터럽트 벡터의 특정 위치로 이동
	- 제어권이 인터럽트 벡터가 가리키는 인터럽트 서비스 루틴으로 이동
	- 올바른 요청인지 확인 후 수행
	- 완료시 제어권을 시스템 콜 다음 명령으로 옮김




### Interrupt

인터럽트 당한 시점의 레지스터와 program counter를 save한 후 CPU의 제어를 인터럽트 처리 루틴에 넘긴다. 

(넓은 의미)
- Interrupt (하드웨어 인터럽트): 하드웨어가 발생시킨 인터럽트 (보통의 의미..)
- Trap (소프트웨어 인터럽트): 
	- Exception: 프로그램이 오류를 범한 경우
	- System Call: 프로그램이 커널 함수를 호출하는 경우

인터럽트 벡터: 해당 인터럽트의 처리 루틴 주소를 가지고 있음

인터럽트 처리 루틴 (Interrupt Service Routine, 인터럽트 핸들러)
: 해당 인터럽트를 처리하는 커널 함수



I/O를 하기 위해서 인터럽트가 두 가지 걸린다.

처음에 사용자 프로그램이. I/O를 요청하기 위해서 시스템 콜. (소프트웨어 인터럽트)

시킨일이 다 끝나면 하드웨어 인터럽트가 걸림.  

=> 
I/O 요청은 소프트웨어 인터럽트
작업 완료 하드웨어 인터럽트



> 현대의 운영체제는 인터럽트에 의해 구동됨.





























