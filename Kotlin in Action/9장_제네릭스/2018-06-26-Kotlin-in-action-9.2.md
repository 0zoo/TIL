# 9.2 실행 시 제네릭스의 동작: 소거된 타입 파라미터와 실체화된 타입 파라미터

JVM의 제네릭스는 보통 **타입 소거(type erasure)** 를 사용해 구현된다.  
(실행 시점에 제네릭 클래스의 인스턴스에 타입 인자 정보가 들어있지 않음)

코틀린에서는 함수를 inline으로 선언함으로써  타입 인자가 지워지지 않게 할 수 있다.  
(이를 실체화 _reify_ 라고 부른다.)

## 9.2.1 실행 시점의 제네릭 타입: 타입 검사와 캐스트

(자바와 마찬가지로) 코틀린 제네릭 타입 인자 정보는 런타임에 지워진다.

예를 들어 `List<String>` 객체를 만들고 그 안에 문자열을 여럿 넣더라도  
실행 시점에는 그 객체를 오직 `List`로만 볼 수 있다.

```kotlin 
val list1: List<String> = listOf("a", "b")
val list2: List<Int> = listOf(1, 2, 3)

// 실행 시점에 둘은 같은 타입의 객체다.
```

타입 인자를 따로 저장하지 않기 때문에
실행 시점에 타입 인자를 검사할 수 없다.

예를 들어 어떤 리스트가 문자열로 이뤄진 리스트인지 다른 객체로 이뤄진 리스트인지를 실행 시점에 검사할 수 없다.

일반적으로 말하자면 `is` 검사에서 타입 인자로 지정한 타입을 검사할 수 없다.

`if( value is List<String> )` 코드는 컴파일시 오류.

- 제네릭 타입 소거의 장점: 메모리 사용량이 줄어든다.

어떤 값이 집합이나 맵이 아닌 리스트라는 사실을 어떻게 확인할 수 있을까??  
-> **스타 프로젝션** 사용

> `if (value is List<*>)`
>> 타입 파라미터가 2개 이상이라면 모든 타입 파라미터에 *을 포함시켜야 한다.

`as`나 `as?` 캐스팅에도 여전히 제네릭 타입을 사용할 수 있다.

하지만 기저 클래스는 같지만 타입 인자가 다른 타입으로 캐스팅해도 여전히 캐스팅에 성공한다는 점을 조심하자.

실행 시점에는 제네릭 타입의 타입 인자를 알 수 없으므로 캐스팅은 항상 성공한다.  
그런 타입 캐스팅을 사용하면 컴파일러가 `"unchecked cast"` 경고 해줌.

하지만 컴파일러는 단순히 경고만 하고 컴파일 진행하기 때문에  
다음 코드처럼 원하는 제네릭 타입으로 캐스팅 가능함.

```kotlin
fun printSum(c: Collection<*>) {
    val intList = c as? List<Int> // 여기서 경고
        ?: throw IllegalArgumentException("..")
    
    println(intList.sum())
}

printSum(listOf(1, 2, 3)) // 6
// 컴파일러가 캐스팅 관련 경고 하지만
// 나머지 코드 정상 컴파일

// 정수 리스트에 

```


## 9.2.2 실체화한 타입 파라미터를 사용한 함수 선언


## 9.2.3 실체화한 타입 파라미터로 클래스 참조 대신


## 9.2.4 실체화한 타입 파라미터의 제약


