# 5.3 지연 계산(lazy) 컬렉션 연산

filter나 map같은 컬렉션 함수는 결과 컬렉션을 즉시 생성한다. 이는 컬렉션 함수를 연쇄하면 매 단계마다 계산 중간 결과를 새로운 컬렉션에 임시로 담는다.

**sequence**를 사용하면 중간 임시 컬렉션을 사용하지 않아도 컬렉션 연산을 인쇄할 수 있다.
```kotlin
people.map(Person::name).filter{ it.startsWith("A") }
// 이 연쇄 호출은 
// filter 결과 리스트와 map 결과 리스트
// 2개를 생성한다. 

people.asSequence() // 원본 컬렉션을 시퀀스로 변환한다.
    .map(Person::name)
    .filter{it.startsWith("A")}
    .toList() // 결과 시퀀스를 다시 리스트로 변환한다.
```
코틀린 **지연 계산 시퀀스**는 _Sequence_ 인터페이스에서 시작한다. 이 인터페이스는 단지 한 번에 하나씩 열거될 수 있는 원소의 시퀀스를 포현할 뿐이다. _Sequence_ 안에는 _iterator_ 하나의 메소드만 존재한다.  

_asSequence_ 확장 함수를 호출하면 어떤 컬렉션이든 시퀀스로 바꿀 수 있다. 시퀀스를 리스트로 만들 때는 _toList_ 를 사용한다. 

항상 시퀀스를 다시 컬렉션으로 되돌려야 하는 것은 아니다.  
시퀀스의 원소를 차례로 이터레이션해야 한다면 시퀀스를 직접 써도 괜찮다.  
하지만 시퀀스 원소를 인덱스처럼 사용해 접근하는 등의 다른 API 메소드가 필요하다면 시퀀스를 리스트로 변환해야 한다.

시퀀스에 대한 연산을 지연 계산하기 때문에 정말 계산을 실행하게 만들려면 최종 시퀀스의 원소를 하나씩 이터레이션 하거나 최종 시퀀스를 리스트로 변환해야 한다. 

#### 노트
큰 컬렉션에 대해서 연산을 연쇄시킬 때는 중간 원소를 재배열하는 비용이 커지기 때문에 지연 계산하는 시퀀스를 사용하는 것을 규칙으로 삼아라.  
(8.2에서 즉시 계산 컬렉션이 더 효율적인 경우 설명함.) 


## 5.3.1 시퀀스 연산 실행: 중간 연산과 최종 연산

1. **중간(intermediate) 연산** : 최초 시퀀스의 원소를 변환하는 방법을 아는 시퀀스를 반환한다. 
2. **최종(terminal) 연산** : 결과를 반환한다.

```kotlin
people.asSequence() 
    .map(Person::name) // 중간 연산
    .filter{it.startsWith("A")} // 중간 연산
    .toList() // 최종 연산

// 시퀀스는 map()filter()map()filter()... 의 순서로 호출함.
// 컬렉션에서 바로 호출하면 map 연산이 모두 끝나고 그 리스트에 대해 
// filter로 새로운 컬렉션을 만들어 낸다는 차이점이 있음.
```

- 중간 연산은 항상 지연 계산된다.

- 최종 연산을 호출해야 연기됐던 모든 계산이 수행된다. 

- 원소당 순차적으로 연산이 적용되기 때문에 결과가 얻어지면 그 이후의 원소에 대해서는 변환이 이루어지지 않을 수도 있다. 

- 컬렉션에 대해 수행하는 연산의 순서도 성능에 영향을 끼친다.

### 자바 스트림과 코틀린 시퀀스 비교
자바 8 스트림의 개념은 시퀀스와 같다.  
코틀린의 컬렉션과 시퀀스에는 스트림 연산을 여러 CPU에서 병렬적으로 실행하는 기능이 없다.

## 5.3.2 시퀀스 만들기

이전의 원소를 인자로 받아 다음 원소를 계산하는 **generateSequence** 함수를 사용해도 시퀀스를 만들 수 있다. 

첫 번째 원소를 지정하고, 시퀀스의 한 원소로부터 다음 원소를 계산하는 방법을 제공함으로써 시퀀스를 만든다.

```kotlin
// 자연수의 시퀀스를 생성하고 사용하기
val naturalNumbers = generateSequence(0){ it+1 }
val numbersTo100 = naturalNumbers.takeWhile{ it <= 100 }
// naturalNumbers 와 numbersTo100 모두 시퀀스이다.

println(numbersTo100.sum()) // 5050
// sum()이 최종 연산.
```

시퀀스를 사용하는 일반적인 용례 중 하나는 객체의 조상으로 이뤄진 시퀀스를 만들어 내는 것이다.

```kotlin
// 상위 디렉토리의 시퀀스를 생성하고 사용하기

// 어떤 파일의 상위 디렉토리에 숨김 속성을 가진 디렉토리가 있는지 검사하는 함수
fun File.isInsideHiddenDirectory() = generateSequence(this){ it.parentFile }.any{ it.isHidden }

val file = File("path")

println(file.isInsideHiddenDirectory())
// true
```
