# Chapter10. 프래그먼트 인자 사용하기

## 프래그먼트로부터 액티비티 시작시키기

`Fragment.startActivity(Intent)`를 호출한다.

### 엑스트라 쓰기

```
뉴인텐트 메서드 추가하기
```

보여줄 크라임 객체의 아이디를 인텐트 엑스트라 데이터로 전달하자.

### 엑스트라 읽기

프래그먼트가 자신을 호스팅하는 액티비티의 인텐트를 가져오는 방법
1. 쉽게 직접 액세스
2. 복잡하지만 유연한 코드 구현

#### 첫 번째 방법. 쉽게 직접 액세스

```java
UUID crimeId = (UUID) getActivity().getIntent()
						.getSerializableExtra(CrimeActivity.EXTRA_CRIME_ID);
mCrime = CrimeLab.get(getActivity()).getCrime(crimeId);
```

### Crime 데이터로 CrimeFragment의 뷰 변경하기

### 직접 액세스하는 방법의 단점

**프래그먼트의 캡슐화**가 어려워진다.

여기에서 CrimeFragment는 더 이상 재사용 가능한 컴포넌트가 아님.  

(`패키지명.크라임_아이디`라는 이름의 엑스트라를 정의하고 있는 인텐트가 있는데, 
이를 갖는 액티비티에 의해 CrimeFragment가 호스팅되어야 하기 때문.)


이보다 더 좋은 방법은 CrimeActivity의 영역이 아닌 CrimeFragment의 인자(argument) 번들에 크라임 아이디를 저장하는 것.  
-> 인텐트의 특정 엑스트라에 의존하지 않고 CrimeFragment가 데이터 액세스 가능.  

## 프래그먼트 인자


- 인자(argument): 번들 객체가 갖는 키와 값으로 된 데이터

```java
Bundle args = new Bundle();
args.putSerializable(EXTRA_MY_OBJECT, myObject);
args.putInt(EXTRA_MY_INT, myInt);
```

### 인자를 프래그먼트에 첨부하기

`Fragment.setArguments(Bundle)`

단, 프래그먼트가 액티비티에 추가되기 전에 첨부해야 함.


`newInstance()`: static 메서드.  
프래그먼트와 번들 객체를 생성하고 번들을 프래그먼트 인자로 설정한다.  
프래그먼트 생성자를 직접 호출하는 대신 사용.


```
// newInstance() 작성하기
```

코드의 독립성이 액티비티와 프래그먼트 양쪽 모두에 필요한 것은 아니다.

### 인자 가져오기

인텐트의 엑스트라를 직접 액세스하는 방법 
(`UUID crimeId = (UUID) getActivity().getIntent().getSerializable(CrimeActivity.EXTRA_CRIME_ID)`) 을 
프래그먼트 인자로부터 UUID를 가져오는 것으로 변경해보자.

```java
UUID crimeId = (UUID) getArguments().getSerializable(ARG_CRIME_ID);
```

## 리스트를 다시 로드하기

리사이클러뷰의 어댑터는 데이터 셋이 변경되었다는 사실을 알아야 데이터를 다시 가져와 리스트에 로드할 수 있다.

사용자가 Back 버튼을 누르면 이전 액티비티가 started 되고 resumed된다.

액티비티가 재실행될 때는 운영체제로부터  `onResume()` 호출을 받고 그것의 FragmentManager가 자신이 호스팅하고 있는 프래그먼트들의 `onResume()`을 호출한다.

리스트를 다시 로드하기 위해 CrimeListFragment에서 `onResume()`을 오버라이드하여 UI를 업데이트하고 `notifyDataSetChanged()` 를 호출하도록 수정해보자.

```
// onResume()에서 리스트 다시 로드하기
```

리사이클러뷰의 데이터를 변경하기 위해 `onStart()`가 아닌 `onResume()`을 오버라이드하는 이유는?    
다른 액티비티가 우리 액티비티의 앞에 있다고 해서 우리 액티비티가 중단될 것이라고 단정할 수 없기 때문.    
만일 다른 액티비티가 transparent(투명) 액티비티라면 우리 액티비티는 중단이 아닌 일시 중지가 될 수 있다.


> 일반적으로 프래그먼트의 뷰를 변경하기에 가장 안전한 메서드가 `onResume()`이다.

![image](https://user-images.githubusercontent.com/38287485/46788029-39894d00-cd74-11e8-93a6-b5c7734cddb0.png)


## 프래그먼트로부터 결과 받기


```java
Fragment.startActivityForResult(...)
Fragment.onActivityResult(...)
```

```java
public void onActivityResult(int requestCode, int resultCode, Intent data){
	if(requestCode == REQUEST_CRIME){
		// 결과 처리 코드
	}
}
```

`Fragment.startActivityForResult(...)`는 호스팅 액티비티로부터 결과 값을 전달받기 위해 추가 코드를 작성해야 한다.

프래그먼트는 액티비티로부터 결과 값을 받을 수 있지만, 프래그먼트 자신의 결과 값은 가질 수 없다.
따라서 프래그먼트는 자신의 `startActivityForResult()`와 `onActivityResult()` 메서드를 갖고 있지만, `setResult()`는 갖지 않는다.

```java
public void returnResult(){
	getActivity().setResult(Activity.RESULT_OK, null);
}
```


## 챌린지: 효율적으로 RecyclerView를 다시 로드하기

CriminalIntent에서 `notifyDataSetChanged()`를 사용하는 것은 비효율적.  
왜냐하면 다시 리스트로 돌아갈 때 기껏해야 한 건의 범죄 데이터만 변경될 것이기 때문.  

이처럼 RecyclerView 리스트의 한 항목만 다시 로드할 때는 
어떤 위치의 항목이 변경되었는지 알아내고 그것을 다시 로드하는
`RecyclerView.Adapter`의 `notifyItemChanged(Int)`를 사용하자.

## 프래그먼트 인자를 사용하는 이유가 뭘까?

언제 메모리가 부족해 회수될지 알 수 없으므로 
프래그먼트가 생성될 때 인스턴스 변수를 설정하는 것은 신뢰할 수 있는 방법이 아니다.

따라서 모든 경우에 제대로 동작되게 하려면 **프래그먼트 인자**를 사용해야 한다.

또 다른 방법으로는   
모든 경우에 사용 가능한 프래그먼트 인스턴스 상태를 보존하는 매커니즘이 있다.  
데이터를 프래그먼트 인스턴스 변수에 저장하고 `onSaveInstance()`에서 (소멸시 호출) 번들 객체에 저장한다. `onCreate()`에서 (인스턴스 생성시 호출) 번들 객체를 꺼내서 사용하면 된다.
그러나, 이 방법은 **유지 관리가 어렵다.**


> 안드로이드 개발자들은 프래그먼트 인자를 사용하는 방법을 선호한다.
